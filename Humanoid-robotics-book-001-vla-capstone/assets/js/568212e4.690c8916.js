"use strict";(globalThis.webpackChunkhumanoid_robotics_book=globalThis.webpackChunkhumanoid_robotics_book||[]).push([[890],{8453:(n,i,e)=>{e.d(i,{R:()=>o,x:()=>a});var s=e(6540);const r={},l=s.createContext(r);function o(n){const i=s.useContext(l);return s.useMemo(function(){return"function"==typeof n?n(i):{...i,...n}},[i,n])}function a(n){let i;return i=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:o(n.components),s.createElement(l.Provider,{value:i},n.children)}},8728:(n,i,e)=>{e.r(i),e.d(i,{assets:()=>t,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"module-2-simulation/sensor-simulation","title":"Sensor Simulation in Robotics","description":"Overview","source":"@site/docs/module-2-simulation/sensor-simulation.md","sourceDirName":"module-2-simulation","slug":"/module-2-simulation/sensor-simulation","permalink":"/Humanoid-robotics-book/docs/module-2-simulation/sensor-simulation","draft":false,"unlisted":false,"editUrl":"https://github.com/irza16/Humanoid-robotics-book/tree/main/docs/module-2-simulation/sensor-simulation.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Week 7: Unity Integration for Advanced Rendering","permalink":"/Humanoid-robotics-book/docs/module-2-simulation/week-7-unity-integration"},"next":{"title":"Module 2 Assignments: Simulation Projects and Exercises","permalink":"/Humanoid-robotics-book/docs/module-2-simulation/assignments"}}');var r=e(4848),l=e(8453);const o={},a="Sensor Simulation in Robotics",t={},c=[{value:"Overview",id:"overview",level:2},{value:"Sensor Simulation Fundamentals",id:"sensor-simulation-fundamentals",level:2},{value:"Importance of Sensor Simulation",id:"importance-of-sensor-simulation",level:3},{value:"Simulation Accuracy vs. Performance",id:"simulation-accuracy-vs-performance",level:3},{value:"LiDAR Simulation",id:"lidar-simulation",level:2},{value:"Gazebo LiDAR Implementation",id:"gazebo-lidar-implementation",level:3},{value:"Ray Sensor Plugin",id:"ray-sensor-plugin",level:4},{value:"Configuration Parameters",id:"configuration-parameters",level:4},{value:"Unity LiDAR Simulation",id:"unity-lidar-simulation",level:3},{value:"Unity LiDAR Component",id:"unity-lidar-component",level:4},{value:"Advantages of Unity LiDAR",id:"advantages-of-unity-lidar",level:4},{value:"Depth Camera Simulation",id:"depth-camera-simulation",level:2},{value:"Gazebo Depth Camera",id:"gazebo-depth-camera",level:3},{value:"Unity Depth Camera",id:"unity-depth-camera",level:3},{value:"Features",id:"features",level:4},{value:"Configuration",id:"configuration",level:4},{value:"IMU Simulation",id:"imu-simulation",level:2},{value:"Gazebo IMU Implementation",id:"gazebo-imu-implementation",level:3},{value:"Noise Modeling",id:"noise-modeling",level:3},{value:"Other Sensor Types",id:"other-sensor-types",level:2},{value:"GPS Simulation",id:"gps-simulation",level:3},{value:"Force/Torque Sensors",id:"forcetorque-sensors",level:3},{value:"Touch Sensors",id:"touch-sensors",level:3},{value:"Sensor Fusion in Simulation",id:"sensor-fusion-in-simulation",level:2},{value:"Multi-Sensor Integration",id:"multi-sensor-integration",level:3},{value:"Validation Techniques",id:"validation-techniques",level:3},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Simulation Complexity",id:"simulation-complexity",level:3},{value:"Computational Requirements",id:"computational-requirements",level:3},{value:"Sensor Calibration in Simulation",id:"sensor-calibration-in-simulation",level:2},{value:"Intrinsic Calibration",id:"intrinsic-calibration",level:3},{value:"Extrinsic Calibration",id:"extrinsic-calibration",level:3},{value:"Sim-to-Real Transfer",id:"sim-to-real-transfer",level:2},{value:"Domain Randomization",id:"domain-randomization",level:3},{value:"Systematic Differences",id:"systematic-differences",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Sensor Validation",id:"sensor-validation",level:3},{value:"Configuration Management",id:"configuration-management",level:3},{value:"Error Handling",id:"error-handling",level:3},{value:"Troubleshooting Common Issues",id:"troubleshooting-common-issues",level:2},{value:"Sensor Data Quality",id:"sensor-data-quality",level:3},{value:"Performance Problems",id:"performance-problems",level:3},{value:"Summary",id:"summary",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(n){const i={h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,l.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(i.header,{children:(0,r.jsx)(i.h1,{id:"sensor-simulation-in-robotics",children:"Sensor Simulation in Robotics"})}),"\n",(0,r.jsx)(i.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(i.p,{children:"This document covers the simulation of various sensors in robotic environments using both Gazebo and Unity. You'll learn to implement realistic sensor models for LiDAR, depth cameras, IMUs, and other common robotic sensors, understanding how to configure them for accurate simulation and perception pipeline development."}),"\n",(0,r.jsx)(i.h2,{id:"sensor-simulation-fundamentals",children:"Sensor Simulation Fundamentals"}),"\n",(0,r.jsx)(i.h3,{id:"importance-of-sensor-simulation",children:"Importance of Sensor Simulation"}),"\n",(0,r.jsx)(i.p,{children:"Sensor simulation is crucial for:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Testing perception algorithms without hardware"}),"\n",(0,r.jsx)(i.li,{children:"Generating diverse training data for AI models"}),"\n",(0,r.jsx)(i.li,{children:"Validating robot behaviors in various conditions"}),"\n",(0,r.jsx)(i.li,{children:"Reducing development costs and risks"}),"\n",(0,r.jsx)(i.li,{children:"Accelerating testing and debugging cycles"}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"simulation-accuracy-vs-performance",children:"Simulation Accuracy vs. Performance"}),"\n",(0,r.jsx)(i.p,{children:"When configuring sensor simulation, you must balance:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Accuracy"}),": How closely the simulation matches real sensors"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Performance"}),": Computational cost of the simulation"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Realism"}),": How believable the sensor data appears"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Diversity"}),": Range of conditions the sensor can simulate"]}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"lidar-simulation",children:"LiDAR Simulation"}),"\n",(0,r.jsx)(i.h3,{id:"gazebo-lidar-implementation",children:"Gazebo LiDAR Implementation"}),"\n",(0,r.jsx)(i.p,{children:"Gazebo provides several LiDAR sensor options:"}),"\n",(0,r.jsx)(i.h4,{id:"ray-sensor-plugin",children:"Ray Sensor Plugin"}),"\n",(0,r.jsx)(i.p,{children:"The ray sensor plugin creates a simulated LiDAR by casting rays and measuring distances to objects."}),"\n",(0,r.jsx)(i.h4,{id:"configuration-parameters",children:"Configuration Parameters"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Samples"}),": Number of rays in the scan"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Min/Max Angle"}),": Angular range of the sensor"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Range Min/Max"}),": Distance range of the sensor"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Resolution"}),": Angular resolution of the scan"]}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"unity-lidar-simulation",children:"Unity LiDAR Simulation"}),"\n",(0,r.jsx)(i.p,{children:"Unity implements LiDAR using raycasting:"}),"\n",(0,r.jsx)(i.h4,{id:"unity-lidar-component",children:"Unity LiDAR Component"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Raycasting for distance measurement"}),"\n",(0,r.jsx)(i.li,{children:"Noise modeling for realistic data"}),"\n",(0,r.jsx)(i.li,{children:"Multiple beam configurations"}),"\n",(0,r.jsx)(i.li,{children:"Point cloud generation"}),"\n"]}),"\n",(0,r.jsx)(i.h4,{id:"advantages-of-unity-lidar",children:"Advantages of Unity LiDAR"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Photorealistic rendering effects"}),"\n",(0,r.jsx)(i.li,{children:"Accurate material properties"}),"\n",(0,r.jsx)(i.li,{children:"Advanced occlusion handling"}),"\n",(0,r.jsx)(i.li,{children:"Customizable noise models"}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"depth-camera-simulation",children:"Depth Camera Simulation"}),"\n",(0,r.jsx)(i.h3,{id:"gazebo-depth-camera",children:"Gazebo Depth Camera"}),"\n",(0,r.jsx)(i.p,{children:"Gazebo provides depth camera simulation that outputs both RGB and depth images."}),"\n",(0,r.jsx)(i.h3,{id:"unity-depth-camera",children:"Unity Depth Camera"}),"\n",(0,r.jsx)(i.p,{children:"Unity offers more realistic depth camera simulation with:"}),"\n",(0,r.jsx)(i.h4,{id:"features",children:"Features"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Physically-based rendering"}),"\n",(0,r.jsx)(i.li,{children:"Lens distortion effects"}),"\n",(0,r.jsx)(i.li,{children:"Depth buffer extraction"}),"\n",(0,r.jsx)(i.li,{children:"Realistic noise patterns"}),"\n"]}),"\n",(0,r.jsx)(i.h4,{id:"configuration",children:"Configuration"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Field of view settings"}),"\n",(0,r.jsx)(i.li,{children:"Resolution and frame rate"}),"\n",(0,r.jsx)(i.li,{children:"Noise and distortion parameters"}),"\n",(0,r.jsx)(i.li,{children:"Depth range and accuracy"}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"imu-simulation",children:"IMU Simulation"}),"\n",(0,r.jsx)(i.h3,{id:"gazebo-imu-implementation",children:"Gazebo IMU Implementation"}),"\n",(0,r.jsx)(i.p,{children:"Gazebo simulates IMU data with realistic noise characteristics."}),"\n",(0,r.jsx)(i.h3,{id:"noise-modeling",children:"Noise Modeling"}),"\n",(0,r.jsx)(i.p,{children:"Real IMU sensors include various noise sources:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Bias"}),": Constant offset that changes over time"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Noise"}),": Random fluctuations in measurements"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Scale Factor Error"}),": Inaccuracies in measurement scaling"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Cross-Axis Sensitivity"}),": Cross-talk between measurement axes"]}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"other-sensor-types",children:"Other Sensor Types"}),"\n",(0,r.jsx)(i.h3,{id:"gps-simulation",children:"GPS Simulation"}),"\n",(0,r.jsx)(i.p,{children:"GPS simulation includes:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Position and velocity measurements"}),"\n",(0,r.jsx)(i.li,{children:"Accuracy modeling based on satellite geometry"}),"\n",(0,r.jsx)(i.li,{children:"Environmental effects (urban canyons, multipath)"}),"\n",(0,r.jsx)(i.li,{children:"Update rate configuration"}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"forcetorque-sensors",children:"Force/Torque Sensors"}),"\n",(0,r.jsx)(i.p,{children:"Force/torque sensors in simulation:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Measure forces and torques at joints"}),"\n",(0,r.jsx)(i.li,{children:"Include noise and drift characteristics"}),"\n",(0,r.jsx)(i.li,{children:"Support for 6-axis force/torque measurements"}),"\n",(0,r.jsx)(i.li,{children:"Integration with robot controllers"}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"touch-sensors",children:"Touch Sensors"}),"\n",(0,r.jsx)(i.p,{children:"Touch sensors for contact detection:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Collision-based touch detection"}),"\n",(0,r.jsx)(i.li,{children:"Pressure sensitivity modeling"}),"\n",(0,r.jsx)(i.li,{children:"Multiple contact point tracking"}),"\n",(0,r.jsx)(i.li,{children:"Haptic feedback simulation"}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"sensor-fusion-in-simulation",children:"Sensor Fusion in Simulation"}),"\n",(0,r.jsx)(i.h3,{id:"multi-sensor-integration",children:"Multi-Sensor Integration"}),"\n",(0,r.jsx)(i.p,{children:"Combine data from multiple sensors:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Synchronize sensor timestamps"}),"\n",(0,r.jsx)(i.li,{children:"Transform data between coordinate frames"}),"\n",(0,r.jsx)(i.li,{children:"Implement sensor calibration procedures"}),"\n",(0,r.jsx)(i.li,{children:"Handle sensor failures and fallbacks"}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"validation-techniques",children:"Validation Techniques"}),"\n",(0,r.jsx)(i.p,{children:"Verify sensor simulation accuracy:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Compare with real sensor data"}),"\n",(0,r.jsx)(i.li,{children:"Test under various environmental conditions"}),"\n",(0,r.jsx)(i.li,{children:"Validate sensor noise characteristics"}),"\n",(0,r.jsx)(i.li,{children:"Check for temporal consistency"}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,r.jsx)(i.h3,{id:"simulation-complexity",children:"Simulation Complexity"}),"\n",(0,r.jsx)(i.p,{children:"Balance simulation quality with performance:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Adjust sensor resolution based on needs"}),"\n",(0,r.jsx)(i.li,{children:"Use Level of Detail (LOD) for complex sensors"}),"\n",(0,r.jsx)(i.li,{children:"Implement efficient raycasting algorithms"}),"\n",(0,r.jsx)(i.li,{children:"Optimize sensor update rates"}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"computational-requirements",children:"Computational Requirements"}),"\n",(0,r.jsx)(i.p,{children:"Different sensors have varying computational costs:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"LiDAR: High computational cost with many rays"}),"\n",(0,r.jsx)(i.li,{children:"Depth cameras: GPU-intensive rendering"}),"\n",(0,r.jsx)(i.li,{children:"IMU: Relatively low computational cost"}),"\n",(0,r.jsx)(i.li,{children:"GPS: Moderate computational requirements"}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"sensor-calibration-in-simulation",children:"Sensor Calibration in Simulation"}),"\n",(0,r.jsx)(i.h3,{id:"intrinsic-calibration",children:"Intrinsic Calibration"}),"\n",(0,r.jsx)(i.p,{children:"Simulate internal sensor parameters:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Camera focal length and principal point"}),"\n",(0,r.jsx)(i.li,{children:"Lens distortion coefficients"}),"\n",(0,r.jsx)(i.li,{children:"LiDAR beam alignment"}),"\n",(0,r.jsx)(i.li,{children:"IMU bias and scale factors"}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"extrinsic-calibration",children:"Extrinsic Calibration"}),"\n",(0,r.jsx)(i.p,{children:"Simulate sensor mounting positions:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Position relative to robot base"}),"\n",(0,r.jsx)(i.li,{children:"Orientation (roll, pitch, yaw)"}),"\n",(0,r.jsx)(i.li,{children:"Coordinate frame relationships"}),"\n",(0,r.jsx)(i.li,{children:"Time synchronization"}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"sim-to-real-transfer",children:"Sim-to-Real Transfer"}),"\n",(0,r.jsx)(i.h3,{id:"domain-randomization",children:"Domain Randomization"}),"\n",(0,r.jsx)(i.p,{children:"Make simulation data more transferable:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Randomize environmental parameters"}),"\n",(0,r.jsx)(i.li,{children:"Vary lighting conditions"}),"\n",(0,r.jsx)(i.li,{children:"Change material properties"}),"\n",(0,r.jsx)(i.li,{children:"Add diverse textures and objects"}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"systematic-differences",children:"Systematic Differences"}),"\n",(0,r.jsx)(i.p,{children:"Account for simulation vs. real differences:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Physics approximation errors"}),"\n",(0,r.jsx)(i.li,{children:"Sensor model inaccuracies"}),"\n",(0,r.jsx)(i.li,{children:"Environmental modeling limitations"}),"\n",(0,r.jsx)(i.li,{children:"Rendering vs. reality gaps"}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsx)(i.h3,{id:"sensor-validation",children:"Sensor Validation"}),"\n",(0,r.jsx)(i.p,{children:"Always validate sensor simulation:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Compare statistical properties with real data"}),"\n",(0,r.jsx)(i.li,{children:"Test perception algorithms in both environments"}),"\n",(0,r.jsx)(i.li,{children:"Monitor for simulation-specific artifacts"}),"\n",(0,r.jsx)(i.li,{children:"Regularly update sensor models"}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"configuration-management",children:"Configuration Management"}),"\n",(0,r.jsx)(i.p,{children:"Manage sensor configurations effectively:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Use configuration files for sensor parameters"}),"\n",(0,r.jsx)(i.li,{children:"Version control for sensor settings"}),"\n",(0,r.jsx)(i.li,{children:"Standardized parameter formats"}),"\n",(0,r.jsx)(i.li,{children:"Automated testing of sensor configurations"}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"error-handling",children:"Error Handling"}),"\n",(0,r.jsx)(i.p,{children:"Implement robust error handling:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Handle sensor data dropouts"}),"\n",(0,r.jsx)(i.li,{children:"Detect and recover from sensor failures"}),"\n",(0,r.jsx)(i.li,{children:"Provide fallback sensor data"}),"\n",(0,r.jsx)(i.li,{children:"Log sensor performance metrics"}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"troubleshooting-common-issues",children:"Troubleshooting Common Issues"}),"\n",(0,r.jsx)(i.h3,{id:"sensor-data-quality",children:"Sensor Data Quality"}),"\n",(0,r.jsx)(i.p,{children:"Issues and solutions:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Noisy Data"}),": Increase simulation quality parameters"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Missing Data"}),": Check sensor plugin configurations"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Inconsistent Data"}),": Verify timing and synchronization"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Drift"}),": Check IMU bias and calibration"]}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"performance-problems",children:"Performance Problems"}),"\n",(0,r.jsx)(i.p,{children:"Optimization strategies:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Reduce sensor resolution temporarily"}),"\n",(0,r.jsx)(i.li,{children:"Limit sensor update rates"}),"\n",(0,r.jsx)(i.li,{children:"Use simpler physics models"}),"\n",(0,r.jsx)(i.li,{children:"Parallelize sensor processing"}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsx)(i.p,{children:"Sensor simulation is a critical component of robotic development, enabling safe and cost-effective testing of perception and navigation systems. Understanding how to configure and validate sensor models is essential for effective sim-to-real transfer."}),"\n",(0,r.jsx)(i.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,r.jsx)(i.p,{children:"Continue with simulation projects and exercises to practice sensor implementation and validation in your chosen simulation platform."})]})}function u(n={}){const{wrapper:i}={...(0,l.R)(),...n.components};return i?(0,r.jsx)(i,{...n,children:(0,r.jsx)(d,{...n})}):d(n)}}}]);